# Datapool Architecture

The MyLoadTest Datapool is designed to be self-hosted on any operating system that supports Node.js.

The guiding design decisions were:
1.  **Minimise dependencies to install**
    The only dependencies are Node.js and the list of Node modules that can be automatically installed by running ```npm install``. There is no need to install a web server or a database.
2.  **No concept of a data "table"**
    Giving users the ability to write "SELECT WHERE" queries encourages them to maintain too much state outside of the application being tested, and creates the need for synchronisation with the test environment. Test data should be stored as either key-value pairs, or as values in a queue, not as rows in a table. Most test data is ephemeral, and users can be encouraged to treat it this way by automatically setting TTL values for each record to enable the automatic removal of old data.
3.  **Lazy creation of queues**
    Explict creation of queues should not be necessary. If you try store data in a queue, it will be silently created.


## Table of Contents

-   [OpenAPI definitions](openapi-definitions)
-   [Express.js](#express-js)
    -   [Express Generator](#express-generator)
    -   [Express Validator](#express-validator)
-   [SQLite](#sqlite)
-   [Node Modules](#node-modules)
    -   [Faker.js](faker-js)
    -   [ESLint](eslint)
    -   [Highlight.js](highlist-js)
-   [Security](#security)
-   [Performance](#performance)
-   [Feature Requests](#feature-requests)


# OpenAPI definitions

> The OpenAPI Specification, previously known as the Swagger Specification, is a specification for machine-readable interface files for describing, producing, consuming, and visualizing RESTful web services.

Having API documentation automatically generated by swagger-ui and available at ```http://<servername>/swagger-ui/``` is important for usability. Originally, I thought that it would be best to have the documentation included as comments in the source code (using swagger-jsdoc), but now I think it is better to keep the OpenAPI definitions in a separate file to make it easy to edit with Swagger Editor, and to import into Postman.

Links:
-   [OpenAPI Guide](https://swagger.io/docs/specification/basic-structure/)
-   [Online Swagger Editor](https://editor.swagger.io/)
-   [Blog post about inline swagger docs](https://blog.logrocket.com/documenting-your-express-api-with-swagger/)
-   [swagger-ui-express](https://www.npmjs.com/package/swagger-ui-express)
-   [swagger-jsdoc ](https://www.npmjs.com/package/swagger-jsdoc)
-   [OpenAPI specification](https://swagger.io/specification/)


# Express.js

Express.js is the most popular back-end web application framework for Node.js. It does not require a separate web server - although it can be run behind a reverse proxy like Nginx to handle higher loads.

An alternative to Express is Koa. Perhaps a future version of the datapool will switch to Koa.

> Koa was built by the same team behind Express, and aims to be a smaller, more expressive, and more robust foundation for web applications


## Express Generator

[Express Generator](https://www.npmjs.com/package/express-generator) creates a skeleton Express project.

```bash
npx express-generator
npm install
npm start

# The generated app has the following directory structure:
# ├── bin/
# │   └── www
# ├── public/
# │   ├── images/
# │   ├── javascripts/
# │   └── stylesheets/
# │       └── style.css
# ├── routes/
# │   ├── index.js
# │   └── users.js
# ├── views/
# │   ├── error.jade
# │   ├── index.jade
# │   └── layout.jade
# ├── app.js
# └── package.json
```

Unfortunately, express-generator was last updated on 03/05/2019 (version 4.16.1 - versions match Express version numbers), so is ridiculously out of date. Here is the ```package.json``` file:
```json
// Note: 
// -   Using tilde ( ~ ) gives you bug fix releases. i.e. 1.1.n
// -   Using caret ( ^ ) gives you backwards-compatible new functionality as well. i.e. 1.n.n
"dependencies": {
    "cookie-parser": "~1.4.4", // Released: 2019-02-13
    "debug": "~2.6.9", // Released: 2017-09-22
    "express": "~4.16.1", // Released: 2017-09-30. Current version: 4.17.3
    "http-errors": "~1.6.3", // Released: 2018-03-30
    "jade": "~1.11.0", // Released: 2015-06-12 (replaced by pug)
    "morgan": "~1.9.1" // Released: 2018-09-11
}
```

It was necessary to bump the Express version from 4.16.x to 4.17.x to add support for the express.raw middleware which was needed for file uploads.


## Express Validator

The express-validator module is middleware that makes it easy to check HTTP GET and POST input values, and to return a reponse with an error message.

Links:
-   <https://express-validator.github.io/docs/custom-error-messages.html>
-   <https://github.com/validatorjs/validator.js#sanitizers>


## Swagger UI

The [swagger-ui-express](https://www.npmjs.com/package/swagger-ui-express) module creates a documentation page from an OpenAPI/Swagger file and provides a useful interface for testing the services.


# SQlite

SQlite is a database engine that is not a standalone process, rather it is a library that provides an interface to a single file-based datastore. Due to how operating systems handle reading and writing files, multiple processes can read from the database concurrently, but writes must be performed sequentially and will lock the entire database (not just a table or a row). This serverless design also creates problems when multiple processes try to write to the same database.

It is unclear whether Express.js will have concurrency problems writing to SQLite, as Node.js is technically a single-threaded process (although it has async IO). The documentation says that SQL TRANSACTIONs might fail with an error like "SQLITE_BUSY" there is contention. If there are concurrency-related problems, then load testing should uncover them. 

A common requirement with databases is to increment a stored value and get the new value. This could be done inside a transaction with an UPDATE, then a SELECT, but it is much simpler if the RETURNING clause is used. This feature has been supported since version 3.35.0 (2021-03-12), but unfortunately the datapool uses an older SQLite version.

The sqlite3 Node package bundles SQLite3 3.32.3 as a fallback if the installing system doesn't include SQLite.The version of SQLite can be checked with ```select sqlite_version();```. Running ```sqlite3 --version``` from the command line may not return the version used by the sqlite3 node package.

Querying the database can be done from the command line with ```sqlite filename.sqlite```, and there are also several SQLite extensions available for VS.Code.

Links:
-   [sqlite3 NPM package](https://www.npmjs.com/package/sqlite3)
-   [The RETURNING clause](https://www.sqlite.org/lang_returning.html)
-   [SQLite Locking](https://www.sqlite.org/lockingv3.html)


# Node Modules

## Faker.js

Faker is a Node module for generating test data (names, phone numbers, etc.). The 

The original Faker module was deleted by the author and has been replaced by @faker-js/faker.

Note that "unique" values in Faker are not really unique, they are just random. This creates problems when using them as input data for load tests, as there is likely to be intermittent failures when duplicate usernames, etc. are rejected, or cause a different/unexpected click-path for the user.

See:
-   <https://www.npmjs.com/package/@faker-js/faker>
-   <https://fakerjs.dev/update.html#i-heard-something-happened-what-s-the-tldr>
-   <https://fakerjs.dev/guide/#node-js>
-   <https://fakerjs.dev/api/name.html#first-name>


## ESLint

ESLint is a tool for encouraging best practices and enfocing  coding styles within a team. But it is used by the datapool to block uploaded code that might be malicious. A better approach might be to not allow code upload, so user-code must be placed in a special directory by the admin, and can be manually reviewed.

ESLint could be used to:
-   prevent the use of certain modules (file-system, http, child_process, etc.)
-   block use of eval/setTimeout/setInterval/new Function()


## Highlight.js

The C-based LoadRunner code examples on the index page should be syntax highlighted. It is best that highlighting be done on the client-side. It would be nice to minimise the JS code that is sent to the client.

The highlight.js module seems to be the best option. See: https://highlightjs.org/

```html
<!-- Example code. When highlightAll() is called, any code in <pre><code> blocks will be highlighted. -->
<link rel="stylesheet" href="/path/to/highlight.min.css">
<script src="/path/to/highlight.min.js"></script>
<script src="/path/to/highlight.cpp.min.js"></script>
<script>hljs.highlightAll();</script>

<pre><code class="language-cpp">...</code></pre>
```

Rather than fiddling with WebPack, a minified, language-specific version can be downloaded from the CDN:

```bash
# core library
curl https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js -o highlight.min.js

# additional language support:
curl https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/cpp.min.js -o highlight.cpp.min.js

# stylesheet
curl https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css -o highlight.min.css
```

Note that the Highlight.js default minified web build includes only ~40 popular languages. 


# Security

It would be a good idea to restrict access to the datapool to just the IP addresses of the load generators.

Security issues:
-   uses HTTP instead of HTTPS
    certificate management would make installation more painful. The LetsEncrypt certbot could be installed, and Express.js supports HTTPS, but there are too many manual steps, and automating the steps would require that the web server can be accessed by LetsEncrypt, and the automation would have to be done twice (to support Windows and Linux).
-   no auth required
    Anyone can read/write datapool data
-   Remote code execution (by design)
    Code can be uploaded with ```POST /code``` and run on the server

Note: the express.static middleware only serves files that are in /public, so there is no way for someone to download module source code by requesting /usercode/example.js directly.


# Performance

The datapool hasn't been load tested yet, so it is unclear how many requests/sec it can handle or what kind of errors occur when it is overloaded. Rather than spending too much time optimising the self-hosted version of the datapool, high-throughput users should use the cloud-hosted version instead.

Performance notes:
-   Even though Node.js is single-treaded, IO is async so multiple requests can be handled concurrently by Express. If Express/Node is the bottleneck, then multiple instances can be run behind a reverse proxy (e.g. Nginx), although this may create concurrency problems when writing to the SQLite database and this design makes installation more complicated.
-   The sqlite3 module has been used is verbose mode (```const sqlite3 = require('sqlite3').verbose();```). This means that SQL errors are more detailed, but may have a higher performance overhead.
-   Debug-level logging is on. It could be disabled to improve performance
-   The SQLite database file containing queues is a single file. Write operations (which, for a queue, includes both adding and removing an item) cause write locking for *entire* database file (not just the table, not just the row). An optimisation would be to have separate database files for each queue.


## Feature Requests

-   Rewrite SQL queries to use the RETURNING clause.
    -   Upgrade the node sqlite3 module once it includes SQLite version 3.35.0 (released on 2021-03-12)
-   Test cases with Postman
-   More example code:
    -   Node.js (export to CSV, generate SQL statement from queue for post-test validation)
    -   LoadRunner TruClient
-   Run some load tests against the datapool (particularly of queues - what happens when an SQL transaction fails?)
-   Better ESLint protections against malicious usercode
-   Switch from Express.js to Koa
    -   replace Jade with Pug
    -   update old Node modules
-   Documentation:
    -   How to change the port for Express
    -   How to log HTTP requests and application errors
    -   Running in dev mode vs production mode
